ORM и Модели
===

[<< документация](readme.md)

ORM — объектно-реляционное отображение.

[http://ru.wikipedia.org/wiki/ORM](http://ru.wikipedia.org/wiki/ORM)

[http://en.wikipedia.org/wiki/Object-relational_mapping](http://en.wikipedia.org/wiki/Object-relational_mapping)

## DVelum ORM

ORM ответственно за хранение данных, описывает их структуру, валидирует для вставки и обновления.

Мы постарались максимально снизить ограничения, которые обычно накладывает ORM, осталось только два:

    запись данных должна происходить через объекты ORM (иначе могут возникнуть проблемы целостности данных);
    для извлечения связей “один ко многим” необходимо сверяться с таблицей связей.

ORM не содержит инструментария выборки списков объектов и цепочек взаимосвязей.

Концепция платформы такова:
* сохраняем и валидируем данные через Orm\Record
* получаем списки, а так же сложные выборки через Model

При сохранении данных, кроме валидации данных происходит инвалидация кэша и запуск классов триггеров.


Модели инстанцируются методом 
```php Model::factory('ObjectName') ``` 
и бывают двух видов:

    виртуальные — если вы не определяли дополнительной логики модели, фабрика моделей вернет вам ссылку на объект, 
    содержащий набор стандартных методов выборки данных;
    расширенные (реальные) — используются в том случае, если вам необходимо расширить логику выборок.

Расширенные модели создаются просто — в папку application\classes\App\Model добавляется файл классом аналогичным названию 
объекта в ORM, при этом "_" в название объекта  - это вложенность дирректории.
Сам класс должен быть отнаследован от Dvelum\Orm\Model, в нем вы описываете дополнительную логику работы с данными объектов,
 например, дополнительные методы по выборке данных с определенными параметрами и условиями 
 (Factory автоматически подхватит этот класс и вернет Вам ссылку на его объект).

При реализации расширенных моделей необходимо помнить, что при работе моделей используется позднее статическое связывание,
 будьте аккуратнее со статическими методами.


В ORM есть стандартные поля, и есть ссылки:

    на объекты  (один к одному) - в качестве данных принимают id-идентификатор объекта;
    на списки объектов (один ко многим) - в качестве данных принимают массив id-идентификаторов объекта;
    ссылки на словари - в качестве данных принимают ключ словаря.


Начиная с версии  0.8.7 DVelum,  для модели может быть индивидуально переопределено подключение к базе данных, 
что позволяет рассредоточить данные по нескольким серверам баз данных, при этом они не обязательно должны быть MySql.

Обратите внимание, что при изменении структуры объектов перевалидация существующих данных не производится, 
это может привести к неблагоприятным последствиям.


Поскольку DVelum - это в первую очередь среда разработки, вы можете действовать, как считаете нужным, мы лишь стараемся 
упростить работу. Специально спроектировали ORM так, чтобы было как можно меньше проблем с прямыми выборками.

### Пример работы:

Создаем объект ORM с именем  "my_object" в [интерфейсе управления ORM](orm_main.md)

```php
<?php
use Dvelum\Orm\Record;
use Dvelum\Orm\Model;
use Dvelum\Db\Select\Filter;

// Инстанцируем модель "my_object"
$myObjectModel = Model::factory('my_object');

// Создаем новый объект ORM типа "my_object"
$myObject = Record::factory('my_object');

try{
    // задаем значения свойств, может бросить исключение валидации
    $myObject->setValues([
        'prop1' => 'val1',
        'prop2' => 'val2',
    ]);
    // сохраняем запись, может вернуть  false  при ошибке
    if(!$myObject->save()){
        throw new Exception('Cannot save my_object '.$myObject->getErrors());
    }   
}catch (\Exception $e){
    // логируем ошибку (системная таблица ошибок)
    $myObjectModel->logError($e->getMessage());
    
}

// пример получения выборки данных с ипользованием упрощенного конструктора запросов
$query = $myObjectModel->query()
                        // список полей, которые нам нужны
                       ->fields(['id','prop1','prop2'])
                        // дополнительные фильтры данных
                       ->filters([
                          // где значение в колонке prop1 равно val1
                          'prop1' => 'val1',
                          // пример более сложного фильтра  
                           new Filter(
                                // колонка
                               'prop2',
                                // значение
                                ['v1','v2','v3'],
                                // тип фильтра
                                Filter::NOT_IN
                            )
                       ])
                       ->params([
                           'sort'=>'name',
                           'dir'=>'DESC',
                           'start'=>0,
                           'limit'=>10
                       ]);
// узнать кол-во строк подходящих под условия фильтрации в запросе
$rowsCount = $query->getCount();
// получить данные
$rows = $query->fetchAll();

```